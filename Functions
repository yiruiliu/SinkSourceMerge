#### transform a QW-form network into Jayant's form
nettransform:=function(network)
local a, i, b, c, e1, e2, e, f, nSources, nEdgesSource,j,Edges;
a:=network[1];
e:=[ ];
	while Size(a)>0 do
		b:=[a[1][1]];
		c:=[a[1]];
			for i in [2..Size(a)] do
				if a[1][2]=a[i][2] then
					Append(b,[a[i][1]]);
					Append(c,[a[i]]);
				fi;
			od;
		e1:=Union(a[1][2],b);
		e2:=[a[1][2],e1];
		Append(e,[e2]);
		a:=Difference(a,c);
	od;
a:=network[2];
f:=[ ];
	while Size(a)>0 do
		b:=[a[1][1]];
		c:=[a[1]];
			for i in [2..Size(a)] do
				if a[1][2]=a[i][2] then
					Append(b,[a[i][1]]);
					Append(c,[a[i]]);
				fi;
			od;

		e1:=Union(a[1][2],b);
		e2:=[a[1][2],e1];
		Append(f,[e2]);
		a:=Difference(a,c);
	od;
Append(e,f);
e:=[e];
nSources:=network[1][1][1]-1;
Edges:=[];
	for j in [1..Size(network[1])] do
		Append(Edges,[network[1][j][1]]);
	od;
nEdgesSource:=Maximum(Edges);
Append(e,[nSources]);
Append(e,[nEdgesSource]);
return e;
end;

#####subfunction that generates equality constraints
EqualityGenerate:=function(A,B,c)
	local list,i,j;
	list:=ZeroMutable( [ 1 .. 2^c-1 ] );
	for i in [1..Size(A)] do
		list[set2int(A[i])]:=1;
	od;
	for j in [1..Size(B)] do
		list[set2int(B[j])]:=-1;
	od;
	list:=Concatenation(ZeroMutable( [ 1 .. c] ),list);
	return list;
end;

#######add equivalent constraint for Anet h5+h6=h(In(t1)); h5=h(In(t1))+h(In(t2))-h(In(t1),In(t2)); h7+h5=h(In(t2)). 
####### h5 is the full common information which is I(In(t2),In(t1))
NCRateRegionOBAnetFull:=function ( ncinstance, usesym, optargs,cedge, extraedge1,extraedge2)
local  rlist, A, b, linrows, G, rlist1, ineq, ineqorb, row, rrA, rrb, 
    onemap, nslist, idx, nsrec, los, lolos, Oi, O, trans_ineq,i,j,A1,B1,B2,A2,c,list,dif;
    rlist := NCShannonBounded( ncinstance );
    A := rlist[1];
    b := rlist[2];
    linrows := rlist[3];
    if usesym = false  then
        G := Group( [ () ] );
    else
        G := NetSymGroup( ncinstance );
    fi;
    if Size( optargs ) > 0  then
        nslist := [  ];
        nsrec := optargs[1];
        for idx  in RecNamesInt( nsrec )  do
            lolos := nsrec.(idx);
            for los  in lolos  do
                if idx = 1  then
                    ineq := ZYNonShannon( los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                else
                    ineq := DFZNonShannon( idx - 1, los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                fi;
            od;
        od;
        Append( A, nslist );
        Append( b, ZeroMutable( [ 1 .. Size( nslist ) ] ) );
    fi;
    #####for Augmented network only
    A1:=[];
    B1:=[];
    c:=ncinstance[3];
    for i in [1..Size(ncinstance[1])] do
		dif:=Difference(ncinstance[1][i][2],ncinstance[1][i][1]);
		for j in [1..Size(dif)] do
			if dif[j]=cedge then
				Append(A1,[ncinstance[1][i][1]]);
			fi; 
		od;
    od;
    B1:=[Union(A1[1],A1[2])];
    B2:=[Union(A1[1],A1[2])];
    A2:=[cedge,extraedge1,extraedge2];
    Append(B1,[[cedge]]);
    list:=EqualityGenerate(A1,B1,c);
    Append(A,[list]);
    Append(b,[0]);
    Append(linrows,[Size(b)]);
    A1:=[];
    B1:=[];
    for i in [1..Size(ncinstance[1])] do
		dif:=Difference(ncinstance[1][i][2],ncinstance[1][i][1]);
		for j in [1..Size(dif)] do
			if dif[j]=extraedge1 then
				Append(A1,[ncinstance[1][i][1]]);
				Append(B1,[[extraedge1]]);
				Append(B1,[[cedge]]);
			fi; 
		od;
    od;
    list:=EqualityGenerate(A1,B1,c);
    Append(A,[list]);
    Append(b,[0]);
    Append(linrows,[Size(b)]);
     A1:=[];
    B1:=[];
    for i in [1..Size(ncinstance[1])] do
		dif:=Difference(ncinstance[1][i][2],ncinstance[1][i][1]);
		for j in [1..Size(dif)] do
			if dif[j]=extraedge2 then
				Append(A1,[ncinstance[1][i][1]]);
				Append(B1,[[extraedge2]]);
				Append(B1,[[cedge]]);
			fi; 
		od;
    od;
    list:=EqualityGenerate(A1,B1,c);
    Append(A,[list]);
    Append(b,[0]);
   Append(linrows,[Size(b)]);
    #####
    rlist1 := symCHM( A, b, linrows, ncinstance[3], G, OnProjPts, OnProjIneq, 
       false );
    Display( Concatenation( "stats:  No. of LPs solved = ", 
       String( rlist1[3][1] ), ", \n\t No. of facets = ", 
       String( Size( rlist1[2] ) ), 
       ", \n\tDD stepsizes beyond initial hull = ", String( rlist1[3][2] ) ) 
     );
    rrA := [  ];
    rrb := [  ];
    for row  in rlist1[2]  do
        onemap := function ( x )
              return 1;
          end;
        if not row = List( [ 1 .. Size( row ) ], onemap )  then
            Append( rrA, [ row{[ 1 .. Size( row ) - 1 ]} ] );
            Append( rrb, [ row[Size( row )] ] );
        fi;
    od;
    trans_ineq := [  ];
    Oi := OrbitsDomain( G, rrA, OnProjIneq );
    for O  in Oi  do
        Append( trans_ineq, [ O[1] ] );
    od;
    return [ trans_ineq, RRparse( ncinstance, trans_ineq ) ];
end;

##########function that computes the outer bound of Anet under partial common information decomposition on sinks.
##########partial common information decompostion means to add only one equivalent constraint h5=h6+h7-h67
NCRateRegionOBAnetpartial:=function ( ncinstance, usesym, optargs,listofedges)
    local  rlist, A, b, linrows, G, rlist1, ineq, ineqorb, row, rrA, rrb, cedge, extraedge1,extraedge2,
    onemap, nslist, idx, nsrec, los, lolos, Oi, O, trans_ineq,i,j,A1,B1,B2,A2,c,list,dif,Ab;
    cedge:= listofedges[1];
    extraedge1:= listofedges[2];
    extraedge2:= listofedges[3];
    rlist := NCShannonBounded( ncinstance );
    A := rlist[1];
    b := rlist[2];
    linrows := rlist[3];
    if usesym = false  then
        G := Group( [ () ] );
    else
        G := NetSymGroup( ncinstance );
    fi;
    if Size( optargs ) > 0  then
        nslist := [  ];
        nsrec := optargs[1];
        for idx  in RecNamesInt( nsrec )  do
            lolos := nsrec.(idx);
            for los  in lolos  do
                if idx = 1  then
                    ineq := ZYNonShannon( los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                else
                    ineq := DFZNonShannon( idx - 1, los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                fi;
            od;
        od;
        Append( A, nslist );
        Append( b, ZeroMutable( [ 1 .. Size( nslist ) ] ) );
    fi;
    #####for Augmented network only
    A1:=[];
    B1:=[];
    c:=ncinstance[3];
    A1:=[[cedge],[extraedge1,extraedge2]];
    B1:=[[extraedge1],[extraedge2]];
    list:=EqualityGenerate(A1,B1,c);
    Append(A,[list]);
    Append(b,[0]);
    Append(linrows,[Size(b)]);
    
    A:=Justmatrixperm(A,ncinstance,listofedges);
    #####
    rlist1 := symCHM( A, b, linrows, ncinstance[3], G, OnProjPts, OnProjIneq, 
       false );
    Display( Concatenation( "stats:  No. of LPs solved = ", 
       String( rlist1[3][1] ), ", \n\t No. of facets = ", 
       String( Size( rlist1[2] ) ), 
       ", \n\tDD stepsizes beyond initial hull = ", String( rlist1[3][2] ) ) 
     );
    rrA := [  ];
    rrb := [  ];
    for row  in rlist1[2]  do
        onemap := function ( x )
              return 1;
          end;
        if not row = List( [ 1 .. Size( row ) ], onemap )  then
            Append( rrA, [ row{[ 1 .. Size( row ) - 1 ]} ] );
            Append( rrb, [ row[Size( row )] ] );
        fi;
    od;
    trans_ineq := [  ];
    Oi := OrbitsDomain( G, rrA, OnProjIneq );
    for O  in Oi  do
        Append( trans_ineq, [ O[1] ] );
    od;
    return [ trans_ineq, RRparse( ncinstance, trans_ineq ),rlist1 ];
end;

NCRateRegionOBAnetpartial2:=function ( ncinstance, usesym, optargs,listofedges)
    local  rlist, A, b, linrows, G, rlist1, ineq, ineqorb, row, rrA, rrb, cedge, extraedge1,extraedge2,
    onemap, nslist, idx, nsrec, los, lolos, Oi, O, trans_ineq,i,j,A1,B1,B2,A2,c,list,dif,Ab,
    A3,b3,linrows3,row1,coneq;
    cedge:= listofedges[1];
    extraedge1:= listofedges[2];
    extraedge2:= listofedges[3];
    rlist := NCShannonBounded( ncinstance );
    A := rlist[1];
    b := rlist[2];
    linrows := rlist[3];
    if usesym = false  then
        G := Group( [ () ] );
    else
        G := NetSymGroup( ncinstance );
    fi;
    if Size( optargs ) > 0  then
        nslist := [  ];
        nsrec := optargs[1];
        for idx  in RecNamesInt( nsrec )  do
            lolos := nsrec.(idx);
            for los  in lolos  do
                if idx = 1  then
                    ineq := ZYNonShannon( los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                else
                    ineq := DFZNonShannon( idx - 1, los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                fi;
            od;
        od;
        Append( A, nslist );
        Append( b, ZeroMutable( [ 1 .. Size( nslist ) ] ) );
    fi;
    #####for Augmented network only
    A1:=[];
    B1:=[];
    c:=ncinstance[3];
    A1:=[[cedge],[extraedge1,extraedge2]];
    B1:=[[extraedge1],[extraedge2]];
    list:=EqualityGenerate(A1,B1,c);
    Append(A,[list]);
    Append(b,[0]);
    Append(linrows,[Size(b)]);
    
    A:=Justmatrixperm(A,ncinstance,listofedges);
    #####
    rlist1 := symCHM( A, b, linrows, ncinstance[3], G, OnProjPts, OnProjIneq, 
       false );
     #######
     A3:=[];
     for row  in rlist1[2]  do
        onemap := function ( x )
              return 1;
          end;
        if not row = List( [ 1 .. Size( row ) ], onemap )  then
            row1:=Concatenation(row,[0]);
            Append( A3, [ row1] );
        fi;
    od;
     b3:=ZeroMutable([1..Size(A3)]);
     linrows3:=[];
     coneq:=ZeroMutable([1..Size(A3[1])]);
     coneq[cedge]:=-1;
     coneq[extraedge1]:=1;
     coneq[Size(coneq)-1]:=-1;
     Append(A3,[coneq]);
     Append(b3,[0]);
     Append(linrows3,[b3]);
     coneq:=ZeroMutable([1..Size(A3[1])]);
     coneq[cedge]:=-1;
     coneq[extraedge2]:=1;
     coneq[Size(coneq)]:=-1;
     Append(A3,[coneq]);
     Append(b3,[0]);
     Append(linrows3,[b3]);
     coneq:=ZeroMutable([1..Size(A3[1])])+1;
     Append(A3,[coneq]);
     Append(b3,[1]);
     A3:=matrixperm(A3,extraedge1,Size(coneq)-1);
     A3:=matrixperm(A3,extraedge2,Size(coneq));
     G := Group( [ () ] );
     rlist1 := symCHM( A3, b3, linrows3, ncinstance[3], G, OnProjPts, OnProjIneq, 
       false );
     ######
    Display( Concatenation( "stats:  No. of LPs solved = ", 
       String( rlist1[3][1] ), ", \n\t No. of facets = ", 
       String( Size( rlist1[2] ) ), 
       ", \n\tDD stepsizes beyond initial hull = ", String( rlist1[3][2] ) ) 
     );
    rrA := [  ];
    rrb := [  ];
    for row  in rlist1[2]  do
        onemap := function ( x )
              return 1;
          end;
        if not row = List( [ 1 .. Size( row ) ], onemap )  then
            Append( rrA, [ row{[ 1 .. Size( row ) - 1 ]} ] );
            Append( rrb, [ row[Size( row )] ] );
        fi;
    od;
    trans_ineq := [  ];
    Oi := OrbitsDomain( G, rrA, OnProjIneq );
    for O  in Oi  do
        Append( trans_ineq, [ O[1] ] );
    od;
    return [ trans_ineq, RRparse( ncinstance, trans_ineq )];
end;

###############Subfunction that permutes column "c1" of matrix "A"
###############with column "c2" of matrix "A"
matrixperm:=function(A,c1,c2)
local B,C,CC;
	B:=TransposedMat(A);
	C:=ShallowCopy(B);
	C[c1]:=B[c2];
	C[c2]:=B[c1];
	CC:=TransposedMat(C);
	return CC;
end;

####subfunction that removes a "list" of rows in matrix "A"
Myremove:=function(A,list)
local B,i;
Sort(list);
B:=ShallowCopy(A);
Remove(B,list[1]);
if Size(list)>1 then
	for i in [2..Size(list)] do
		Remove(B,list[i]-i+1);
	od;
fi;
return B;
end;

#############subfunction that removes a "list" of columns in matrix "A"
Myremovetrans:=function(A,list)
local B;
B:=TransposedMat(A);
B:=Myremove(B,list);
B:=TransposedMat(B);
return B;
end;

##############subfunction that: 
##############1. removes edge capacity constaints(ROWS of matrix [A|b]) H(listofedges[i])<=R(listofedges[i]) 
##############2. permutes edge capacity variables R(listofedges[i]) with edge entropy variable H(listofedges[i]) (COLUMNS of matrix [A|b])
##############2. removes edge capacity variables (COLUMNS of matrix A after step 2) R(listofedges[i])
getridandtrans:=function(ncinstance,A,b,linrows,listofedges)
local j,rrlist,conineq,Aprime,bprime,L,Lprime,linrowsprime,i,k,c1,c2;
Aprime:=ShallowCopy(A);
rrlist:=[];
for j  in listofedges  do
	conineq 
	 := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
	conineq[j] := -1;
	conineq[ncinstance[3] + set2int( [ j ] )] := 1;
    for i in [1..Size(A)] do
		if A[i]=conineq then
		   Append(rrlist,[i]);
		fi;
    od;
od;
Aprime:=Myremove(Aprime,rrlist);
bprime:=Myremove(b,rrlist);
L:= ZeroMutable( [1..Size(b)] );
for k in [1..Size(linrows)] do
	L[linrows[k]]:=1;
od;
Lprime:=Myremove(L,rrlist);
linrowsprime:=[];
for k in [1..Size(Lprime)] do
	if Lprime[k]=1 then
		Append(linrowsprime,[k]);
	fi;
od;
rrlist:=[];
for i in listofedges do
    c1:=i;
    c2:=ncinstance[3] + set2int([i]);
	Aprime:=matrixperm(Aprime,c1,c2); 
	Append(rrlist,[c2]);
od;
Aprime:=Myremovetrans(Aprime,rrlist);
return [Aprime,bprime,linrowsprime];
end;

###########subfunction that computes region of entropic vectors that is bounded together by
###########shannon outer bound and network constraints of a network with out the R1+R2+..RN<=1 constaint
NCShannonBoundedNosumto1:=function ( ncinstance )
    local  ShOB, i, linrows, con, conlin, j, conineq;
    ShOB := GenShannonUnBounded( ncinstance[3] );
    i := Size( ShOB[1] ) + 1;
    linrows := [  ];
    for con  in ncinstance[1]  do
        conlin := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 ] );
        conlin[set2int( con[1] )] := 1;
        conlin[set2int( con[2] )] := -1;
        Append( ShOB[1], [ conlin ] );
        Append( ShOB[2], [ 0 ] );
        Append( linrows, [ i ] );
        i := i + 1;
    od;
    conlin := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 ] );
    for j  in [ 1 .. ncinstance[2] ]  do
        conlin[set2int( [ j ] )] := 1;
    od;
    conlin[set2int( [ 1 .. ncinstance[2] ] )] := -1;
    Append( ShOB[1], [ conlin ] );
    Append( ShOB[2], [ 0 ] );
    Append( linrows, [ i ] );
    i := i + 1;
    for j  in [ 1 .. Size( ShOB[1] ) ]  do
        ShOB[1][j] := Concatenation( ZeroMutable( [ 1 .. ncinstance[3] ] ), 
           ShOB[1][j] );
    od;
    for j  in [ 1 .. ncinstance[2] ]  do
        conineq 
         := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := 1;
        conineq[ncinstance[3] + set2int( [ j ] )] := -1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
        conineq 
         := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := -1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
    od;
    for j  in [ ncinstance[2] + 1 .. ncinstance[3] ]  do
        conineq 
         := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := -1;
        conineq[ncinstance[3] + set2int( [ j ] )] := 1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
        conineq 
         := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := -1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
    od;
    return [ ShOB[1], ShOB[2], linrows ];
end;

########subfunction that just permutes columns of matrix "A"
Justmatrixperm:=function(A,ncinstance,listofedges)
local i,c1,c2,Aprime;
Aprime:=ShallowCopy(A);
for i in listofedges do
	c1:=i;
	c2:=ncinstance[3] + set2int([i]);
	Aprime:=matrixperm(Aprime,c1,c2);
od;
return Aprime;
end;
#######function that computes the outer bound of a sink-source merged network containing N1+N2 variables,
#######where N1 and N2 denotes the number of variables in network net1_sink and that in network net2_source, respectively.
NCRateRegionOBGRO:=function ( ncinstance, usesym, optargs,listofedges)
    local  rlist, A, b,A1,b1, linrows, G, rlist1, ineq, ineqorb, row, rrA, rrb, 
    onemap, nslist, idx, nsrec, los, lolos, Oi, O, trans_ineq,i,j,c,list,dif,Ab,conineq;
    rlist := NCShannonBoundedNosumto1( ncinstance );
    A := rlist[1];
    b := rlist[2];
    linrows := rlist[3];
    if usesym = false  then
        G := Group( [ () ] );
    else
        G := NetSymGroup( ncinstance );
    fi;
    if Size( optargs ) > 0  then
        nslist := [  ];
        nsrec := optargs[1];
        for idx  in RecNamesInt( nsrec )  do
            lolos := nsrec.(idx);
            for los  in lolos  do
                if idx = 1  then
                    ineq := ZYNonShannon( los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                else
                    ineq := DFZNonShannon( idx - 1, los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                fi;
            od;
        od;
        Append( A, nslist );
        Append( b, ZeroMutable( [ 1 .. Size( nslist ) ] ) );
    fi;
    #####Getting rid of rows and switch columns
    Ab:=getridandtrans(ncinstance,A,b,linrows,listofedges);
    A1:=Ab[1];
    b1:=Ab[2];
    linrows:=Ab[3];
   A:=[];
   for i in [1..Size(A1)] do;
	   Append(A,[A1[i]]);
   od;
    conineq := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3]-Size(listofedges) ] );
    for j  in [ 1 .. ncinstance[3] ]  do
        conineq[j] := 1;  
    od;
    Append( A, [ conineq ] );
    Append( b1, [ 1 ] );#####R<Rvalue
    #####
    rlist1 := symCHM( A, b1, linrows, ncinstance[3], G, OnProjPts, OnProjIneq, 
       false );
    Display( Concatenation( "stats:  No. of LPs solved = ", 
       String( rlist1[3][1] ), ", \n\t No. of facets = ", 
       String( Size( rlist1[2] ) ), 
       ", \n\tDD stepsizes beyond initial hull = ", String( rlist1[3][2] ) ) 
     );
    rrA := [  ];
    rrb := [  ];
    for row  in rlist1[2]  do
        onemap := function ( x )
              return 1;
          end;
        if not row = List( [ 1 .. Size( row ) ], onemap )  then
            Append( rrA, [ row{[ 1 .. Size( row ) - 1 ]} ] );
            Append( rrb, [ row[Size( row )] ] );
        fi;
    od;
    trans_ineq := [  ];
    Oi := OrbitsDomain( G, rrA, OnProjIneq );
    for O  in Oi  do
        Append( trans_ineq, [ O[1] ] );
    od;
    return [ trans_ineq, RRparse( ncinstance, trans_ineq )];
end;

#######subfuntion concatenation two outer bound
ConcatenateOB:=function(OB1,OB2)
local OB,i,len1,len2,ob1,ob2,Ob;
len1:=Size(OB1[1]);
len2:=Size(OB2[1]);
ob1:=ZeroMutable([1..len1]);
ob2:=ZeroMutable([1..len2]);
OB:=[];
for i in [1..Size(OB1)] do
	Ob:=ShallowCopy(OB1[i]);
	Ob:=Concatenation(Ob,ob1);
	Append(OB,[Ob]);
od;
for i in [1..Size(OB2)] do
	Ob:=ShallowCopy(OB2[i]);
	Ob:=Concatenation(ob2,Ob);
	Append(OB,[Ob]);
od;
return OB;
end;

##subfunction  sortpapallel for matrix
MySortParallel:=function(OB,list)
local list1,i,OB1,ob;
OB1:=[];
for i in [1..Size(OB)] do
        ob:=ShallowCopy(OB[i]);
	list1:=ShallowCopy(list);
	SortParallel(list1,ob);
	Append(OB1,[ob]);
od;
return OB1;
end;


###project JAnetOB+JCnetOB  (Ax<=0),projoutVariables need to be either 6 or 8
ProjectJAnetOBJCnetOB:=function(JAnetOB,JCnetOB,projoutVariables)
local Alen,Clen,list,list1,i,OB,b,linrows,rlist1,G,c;
Alen:=Size(JAnetOB[1]);
Clen:=Size(JCnetOB[1]);
list:=[1..Alen+Clen];
list1:=ShallowCopy(list);
if projoutVariables=8 then
	for i in [1..Clen-5] do
		list1[i+Alen-3]:=list[Size(list)-Clen+5+i];
		list1[Size(list)-Clen+5+i]:=list[i+Alen-3];
	od;
elif projoutVariables=6 then
	for i in [1..Clen-3] do
		list1[i+Alen-3]:=list[Size(list)-Clen+3+i];
		list1[Size(list)-Clen+3+i]:=list[i+Alen-3];
	od;
else 
	Print("Error!!! projoutVariables shoule be either 6 or 8");
	return;
fi;
OB:=ConcatenateOB(JAnetOB,JCnetOB);
b:=ZeroMutable([1..Size(OB)]);
G := Group( [ () ] );
linrows:=[];
c:=ZeroMutable( [1..Alen+Clen])+1;
Append(OB,[c]);
Append(b,[1]);
c:=ZeroMutable( [1..Alen+Clen]);
c[Alen-2]:=1;
c[Alen+3]:=-1;
Append(OB,[c]);
Append(b,[0]);
Append(linrows,[Size(b)]);
c:=ZeroMutable( [1..Alen+Clen]);
c[Alen-1]:=1;
c[Alen+1]:=-1;
Append(OB,[c]);
Append(b,[0]);
Append(linrows,[Size(b)]);
c:=ZeroMutable( [1..Alen+Clen]);
c[Alen]:=1;
c[Alen+2]:=-1;
Append(OB,[c]);
Append(b,[0]);
Append(linrows,[Size(b)]);
c:=ZeroMutable( [1..Alen+Clen]);
c[Alen+4]:=1;
c[Alen+1]:=-1;
c[Alen+3]:=-1;
Append(OB,[c]);
Append(b,[0]);
Append(linrows,[Size(b)]);
c:=ZeroMutable( [1..Alen+Clen]);
c[Alen+5]:=1;
c[Alen+2]:=-1;
c[Alen+3]:=-1;
Append(OB,[c]);
Append(b,[0]);
Append(linrows,[Size(b)]);
OB:=MySortParallel(OB,list1);
 rlist1 := symCHM( OB, b, linrows, Alen+Clen-projoutVariables, G, OnProjPts, OnProjIneq, 
       false );
return rlist1;
end;
###############################################################################
######subfunction of common information decomposition on sources
Net2CommonInforNetgeneral:=function(net,sourcee1,sourcee2)
	local source1,source2,nSources,nEdges,Q,W,n1,n2,n3,n33,n4,n44,n5,i,j;
	source1:=Minimum(sourcee1,sourcee2);
	source2:=Maximum(sourcee1,sourcee2);
	nSources:=net[1][1][1]-1;
	nEdges:=Size(net[1]);
	if Minimum(source1, source2)<1 then
		Print("Error!!! Input source1 and source2 should be greater than or equal to 0");
		return;
	fi;
	if Maximum(source1,source2)>nSources then
		Print("Error!!! Input source1 and source2 should be less than or equal to # of sources");
		return;
	fi;
	if source1=source2 then
		Print("Error!!! source1 source2 should be different");
		return;
	fi;
	if nSources=1 then
		Print("Error!!! Input net should have at least 2 sources");
		return;
	fi;
	Q:=[];
	n1:=[nSources+2,[source1, nSources+1]];
	n2:=[nSources+3,[source2, nSources+1]];
	Append(Q,[n1,n2]);
	for i in [1..Size(net[1])] do
		n3:=ShallowCopy(net[1][i]);
		n3[1]:=n3[1]+3;
		n33:=ShallowCopy(n3[2]);
		for j in [1..Size(n33)] do
			if n33[j]>nSources then
				n33[j]:=n33[j]+3;
			elif n33[j]=source1 then
				n33[j]:=nSources+2;
			elif n33[j]=source2 then
				n33[j]:=nSources+3;
			fi;
		od;
		Sort(n33);
		n3[2]:=n33;
		Append(Q,[n3]);
	od;
	W:=[];
	for i in [1..Size(net[2])] do
		n4:=ShallowCopy(net[2][i]);
		n44:=ShallowCopy(n4[2]);
		for j in [1..Size(n44)] do
			if n44[j]=source1 then
				n44[j]:=nSources+2;
			elif n44[j]=source2 then
				n44[j]:=nSources+3;
			elif n44[j]>nSources then
				n44[j]:=n44[j]+3;
			fi;
		od;
		Sort(n44);
		n4[2]:=n44;
		if n4[1]=source1 then
			n5:=ShallowCopy(n4);
			n5[1]:=nSources+1;
			Append(W,[n4,n5]);
		elif n4[1]=source2 then
			n5:=ShallowCopy(n4);
			n5[1]:=nSources+1;
			Append(W,[n4,n5]);
		else
			Append(W,[n4]);
		fi;
	od;
	return [Q,W];
end;

##subfunction that extracts In(t)s
numOfSinks:=function(net)
local W,i,Sinks;
W:=net[2];
Sinks:=[];
for i in [1..Size(W)] do
    if not W[i][2] in Sinks then
		Append(Sinks,[W[i][2]]);
	fi;
od;
return Sinks;
end;

############Common information decomposition on sinks
AddRateVariable2:=function(net,sink1,sink2)
local Sinks,newedge1,newedge2,newedge3,newedge4, nEdges, nSources, Q, W;
if Maximum(sink1,sink2)>Size(net[2]) or Minimum(sink1,sink2)<0 then
	Print("Error! Please input the right index of sink nodes.");
	return;
fi;
Sinks:=numOfSinks(net);
nEdges:=Size(net[1]);
nSources:=net[1][1][1]-1;
newedge1:=[nEdges+nSources+1];
newedge2:=[nEdges+nSources+1];
newedge3:=[nEdges+nSources+2];
newedge4:=[nEdges+nSources+3];
Append(newedge1,[Sinks[sink1]]);
Append(newedge2,[Sinks[sink2]]);
Append(newedge3,[Sinks[sink1]]);
Append(newedge4,[Sinks[sink2]]);
Q:=ShallowCopy(net[1]);
W:=ShallowCopy(net[2]);
Append(Q,[newedge1]);
Append(Q,[newedge2]);
Append(Q,[newedge3]);
Append(Q,[newedge4]);
return [Q,W];
end;

#####subfunction
numOfSinks:=function(net)
local W,i,Sinks;
W:=net[2];
Sinks:=[];
for i in [1..Size(W)] do
    if not W[i][2] in Sinks then
		Append(Sinks,[W[i][2]]);
	fi;
od;
return Sinks;
end;

####sink source merge with N1+N2-2 variables
SinkSourceMerge:=function(net1,sink1,sink2,net2,source1,source2)
local Anet1,extranSources1,nSources1,nSources2,nEdges1,AQ1,AW1,i,j,n1,n11,r1,Dsources2,r2,Addrateindex,Sinks1,n2,n22,n222,r3,IncomingMessageofsink,extranEdges;
Anet1:=ShallowCopy(net1);
nSources1:=net1[1][1][1]-1;
nSources2:=net2[1][1][1]-1;
nEdges1:=Size(net1[1]);
if Minimum(source1, source2)<1 then
	Print("Error!!! Input source1 and source2 should be greater than or equal to 0");
	return;
fi;
if Maximum(source1,source2)>nSources2 then
	Print("Error!!! Input source1 and source2 should be less than or equal to # of sources");
	return;
fi;
if source1=source2 then
	Print("Error!!! source1 source2 should be different");
	return;
fi;
if nSources2=1 then
	Print("Error!!! Input net should have at least 2 sources");
	return;
fi;
extranSources1:=nSources2-2;
if nSources2>2 then
	AQ1:=[];
	for i in [1..Size(Anet1[1])] do
	    n1:=ShallowCopy(Anet1[1][i]);
		if n1[1]>nSources1 then
			n1[1]:=n1[1]+extranSources1;
		fi;
		n11:=ShallowCopy(n1[2]);
		for j in [1..Size(n11)] do
			if n11[j]>nSources1 then
				n11[j]:=n11[j]+extranSources1;
			fi;
		od;
		n1[2]:=n11;
		Append(AQ1,[n1]);
	od;
	AW1:=[];
	for i in [1..Size(Anet1[2])] do
		n1:=ShallowCopy(Anet1[2][i]);
		if n1[1]>nSources1 then
			n1[1]:=n1[1]+extranSources1;
		fi;
		n11:=ShallowCopy(n1[2]);
		for j in [1..Size(n11)] do
			if n11[j]>nSources1 then
				n11[j]:=n11[j]+extranSources1;
			fi;
		od;
		n1[2]:=n11;
		Append(AW1,[n1]);
	od;
else
AQ1:=ShallowCopy(Anet1[1]);
AW1:=ShallowCopy(Anet1[2]);
fi;

extranEdges:=nSources1+nEdges1+1;
Dsources2:=[-1];
if extranSources1>0 then
	r1:=rec();
	Dsources2:=Difference([1..nSources2],[source1,source2]);
	for i in [1..Size(Dsources2)] do
		r1.(Dsources2[i]):=nSources1+i;
	od;
fi;
r2:=rec();
Addrateindex:=nSources1+nEdges1+extranSources1-2;
Sinks1:=numOfSinks([AQ1,AW1]);
r2.(source1):=Sinks1[sink1];
r2.(source2):=Sinks1[sink2];	
##Append(AQ1,[[Addrateindex+1,Sinks1[sink1]]]);
##Append(AQ1,[[Addrateindex+2,Sinks1[sink2]]]);
for i in [1..Size(net2[1])] do
	n2:=ShallowCopy(net2[1][i]);
	n2[1]:=n2[1]+Addrateindex;
	n22:=ShallowCopy(n2[2]);
	n222:=[];
	for j in [1..Size(n22)] do
		if n22[j] in [source1,source2] then
			n222:=Union(n222,r2.(n22[j]));
		elif n22[j] in Dsources2 then
			n222:=Union(n222,[r1.(n22[j])]);
		else
			n222:=Union(n222,[n22[j]+Addrateindex]);
		fi;
	od;
	n2[2]:=n222;
	Append(AQ1,[n2]);
od;
r3:=rec();
r3.(source1):=sink1;
r3.(source2):=sink2;
for i in [1..Size(net2[2])] do
	n2:=ShallowCopy(net2[2][i]);
	n22:=ShallowCopy(n2[2]);
	n222:=[];
	for j in [1..Size(n22)] do
		if n22[j] in [source1,source2] then
			Append(n222,r2.(n22[j]));
		elif n22[j] in Dsources2 then
			Append(n222,[r1.(n22[j])]);
		else
			Append(n222,[n22[j]+Addrateindex]);
		fi;
	od;
	n222:=Union([n222]);
	n2[2]:=n222;
	if n2[1] in [source1,source2] then
		IncomingMessageofsink:=Sinks1[r3.(n2[1])];
		n2[1]:=IncomingMessageofsink;
		if Size(n2[1])>1 then
			for j in [1..Size(n2[1])] do
				n222:=[];
				n222[1]:=n2[1][j];
				n222[2]:=n2[2];
				Append(AW1,[n222]);
			od;
		else
			n2[1]:=n2[1][1];
			Append(AW1,[n2]);
		fi;
	else 
		Append(AW1,[n2]);
	fi;
	
od;
return [AQ1,AW1];
end;

####sink source merge with 8 variables
SinkSourceMerge2:=function(net1,sink1,sink2,net2,source1,source2)
local Anet1,extranSources1,nSources1,nSources2,nEdges1,AQ1,AW1,i,j,n1,n11,r1,Dsources2,
r2,r4,Addrateindex,Sinks1,n2,n22,n222,r3,IncomingMessageofsink,extranEdges;
Anet1:=ShallowCopy(net1);
nSources1:=net1[1][1][1]-1;
nSources2:=net2[1][1][1]-1;
nEdges1:=Size(net1[1]);
if Minimum(source1, source2)<1 then
	Print("Error!!! Input source1 and source2 should be greater than or equal to 0");
	return;
fi;
if Maximum(source1,source2)>nSources2 then
	Print("Error!!! Input source1 and source2 should be less than or equal to # of sources");
	return;
fi;
if source1=source2 then
	Print("Error!!! source1 source2 should be different");
	return;
fi;
if nSources2=1 then
	Print("Error!!! Input net should have at least 2 sources");
	return;
fi;
extranSources1:=nSources2-2;
if nSources2>2 then
	AQ1:=[];
	for i in [1..Size(Anet1[1])] do
	    n1:=ShallowCopy(Anet1[1][i]);
		if n1[1]>nSources1 then
			n1[1]:=n1[1]+extranSources1;
		fi;
		n11:=ShallowCopy(n1[2]);
		for j in [1..Size(n11)] do
			if n11[j]>nSources1 then
				n11[j]:=n11[j]+extranSources1;
			fi;
		od;
		n1[2]:=n11;
		Append(AQ1,[n1]);
	od;
	AW1:=[];
	for i in [1..Size(Anet1[2])] do
		n1:=ShallowCopy(Anet1[2][i]);
		if n1[1]>nSources1 then
			n1[1]:=n1[1]+extranSources1;
		fi;
		n11:=ShallowCopy(n1[2]);
		for j in [1..Size(n11)] do
			if n11[j]>nSources1 then
				n11[j]:=n11[j]+extranSources1;
			fi;
		od;
		n1[2]:=n11;
		Append(AW1,[n1]);
	od;
else
AQ1:=ShallowCopy(Anet1[1]);
AW1:=ShallowCopy(Anet1[2]);
fi;

extranEdges:=nSources1+nEdges1+1;
Dsources2:=[-1];
if extranSources1>0 then
	r1:=rec();
	Dsources2:=Difference([1..nSources2],[source1,source2]);
	for i in [1..Size(Dsources2)] do
		r1.(Dsources2[i]):=nSources1+i;
	od;
fi;
r2:=rec();
Addrateindex:=nSources1+nEdges1+extranSources1;
Sinks1:=numOfSinks([AQ1,AW1]);
r2.(source1):=Sinks1[sink1];
r2.(source2):=Sinks1[sink2];
r4:=rec();
r4.(source1):=1+Addrateindex;
r4.(source2):=2+Addrateindex;
Append(AQ1,[[r4.(source1),r2.(source1)]]);
Append(AQ1,[[r4.(source2),r2.(source2)]]);	
##Append(AQ1,[[Addrateindex+1,Sinks1[sink1]]]);
##Append(AQ1,[[Addrateindex+2,Sinks1[sink2]]]);
for i in [1..Size(net2[1])] do
	n2:=ShallowCopy(net2[1][i]);
	n2[1]:=n2[1]+Addrateindex;
	n22:=ShallowCopy(n2[2]);
	n222:=[];
	for j in [1..Size(n22)] do
		if n22[j] in [source1,source2] then
			n222:=Union(n222,[r4.(n22[j])]);
		elif n22[j] in Dsources2 then
			n222:=Union(n222,[r1.(n22[j])]);
		else
			n222:=Union(n222,[n22[j]+Addrateindex]);
		fi;
	od;
	n2[2]:=n222;
	Append(AQ1,[n2]);
od;
r3:=rec();
r3.(source1):=sink1;
r3.(source2):=sink2;
for i in [1..Size(net2[2])] do
	n2:=ShallowCopy(net2[2][i]);
	n22:=ShallowCopy(n2[2]);
	n222:=[];
	for j in [1..Size(n22)] do
		if n22[j] in [source1,source2] then
			n222:=Union(n222,[r4.(n22[j])]);
		elif n22[j] in Dsources2 then
			n222:=Union(n222,[r1.(n22[j])]);
		else
			n222:=Union(n222,[n22[j]+Addrateindex]);
		fi;
	od;
	n2[2]:=n222;
	if n2[1] in [source1,source2] then
		n2[1]:=r4.(n2[1]);
		Append(AW1,[n2]);
	fi;
	
od;
return [AQ1,AW1];
end;
